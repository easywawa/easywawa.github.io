---
layout: post
category: Linux
title: 系统中断计息
tagline: by 噜噜噜
tags: 
  - 中断
published: true
---



<!--more-->

### 一、中断

#### 1、处理过程

- 中断当前程序并保护断点
- 转入中断服务入口
- 保护现场
- 执行中断服务程序
- 恢复现场
- 中断返回

#### 2、名词解释

##### ①中断控制器：

Intel平台流行的做法是高级可编程将中断控制器(APIC)集成到南桥芯片（I/O Controller Hub）中

##### ②硬中断

由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包的时候，就会发出一个中断。我们通常所说的中断指的是硬中断(hardirq)。

##### ③软中断

为了满足实时系统的要求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成

##### ④中断嵌套

Linux下硬中断是可以嵌套的，但是没有优先级的概念，也就是说任何一个新的中断都可以打断正在执行的中断，但同种中断除外。

软中断不能嵌套，但相同类型的软中断可以在不同CPU上并行执行

#### 3、中断的代码实现

[]: https://cloud.tencent.com/developer/article/1518703



### 二、定义机制

#### 1、CPU中断的机制

- 中断机制是使得cpu具有**异步处理**能力的机制，就是先暂停他的序列  来执行一些其他指令。因此**中断是多程序并发执行的前提条件**
- 其他硬件可以给cpu发电信号，cpu收到这个信号就暂停当前的指令，去执行中断函数。**cpu上不是有许多针嘛，其中一个就是用来收中断信号的**
- 内核启动的时候会配置一个**中断向量表**，**一个硬件关联一个整数**，也就是数组下标，比如，键盘关联5，键盘给cpu发中断，cpu就会收到5号中断，就会去执行函数指针数组中的第五个函数
- 主板或者cpu内部有一个硬件叫**timer定时器，关联32号中断，它每秒发送一百次中断**，cpu就去执行32号中断函数，然后选择一个进程去执行



`中断向量表：CPU把内存中从0开始的1KB空间作为一个中断向量表，系统中断向量表中共可保存256个中断向量入口，即IDT中包含的256个中断描述符（对应256个中断向量）`

#### 2、中断的本质

中断的本质：**发生中断就意味着需要操作系统介入，开展管理工作**

**用户态到核心态的转换就是通过中断机制实现的，并且中断是唯一途径**，核心态到用户态的切换时通过执行一个特权指令，将程序状态字（PSW）标志位设置为用户态



#### 3、中断请求概述

设备通过相应的中断线向中断控制器发送高电平以产生中断信号，而操作系统则会从中断控制器的状态位取得那根中断线上产生的中断

因此在使用中断线前，就得对相应的中断线进行申请。无论采用共享中断方式还是独占一个中断，申请过程都是先讲所有的中断线进行扫描，得出哪些没有别占用，从其中选择一个作为该设备的IRQ。其次，通过中断申请函数申请相应的IRQ。最后，根据申请结果查看中断是否能够被执行。



#### 4、上下半部机制

问题的产生：期望让中断处理程序运行得快，并想让它完成的工作量多，这两个目标相互制约。这时候就产生了上下半部机制来解决。

##### ①上半部：

中断处理程序是上半部，接收中断，他就开始执行，但只能做**有时间严格限制的工作**。能够被稍后完成的工作会被推到下半部完成。

**上半部执行时系统不响应其他中断**。

##### ②下半部：

下半部的实现有**软中断实现**，**tasklet实现**和**工作队列实现**，并且**执行期间是响应所有的中断的**。



`举例：用网卡接收数据来说明上下半部的工作方式：`

`上半部：及时的读取数据包到内存，防止因为延迟等原因导致丢失；下半部：读取到内存之后，对这些数据的处理不再紧迫，这时候的内存中的数据就交给下半部程序去处理`

##### ③上下半部划分的原则

- 如果一个任务对时间非常敏感，将其放在中断处理程序中执行
- 如果一个任务和硬件有关，将其放在中断处理程序中执行
- 如果一个任务要保证不被其他中断打断，将其放在中断处理程序中执行
- 其他所有任务，考虑放置在下半部执行

### 三、下半部机制的几种方式

#### 1、软中断

软中断一般是“可延迟函数”的总称，软中断执行中断处理程序留给它去完成的剩余任务，而且可以在多个CPU上并行执行，使得总的系统效率可以更高。它的特性包括：

- 产生后并不是马上可以执行，必须要等待内核的调度才能执行。软中断不能被自己打断，只能被硬件中断打断（上半部）
- 可以并发运行在多个CPU上（即使同一类型的也可以）。所以软中断必须设计为可重入的函数（允许多个CPU同时操作），因此也需要使用自旋锁来保护其数据结构。
- 软中断用轮询的方式处理。假如正好是最后一种中断，则必须循环完所有的中断类型，才能最终执行对应的处理函数。显然当年开发人员为了保证轮询的效率，于是限制中断个数为32个。

#### 2、tasklet

tasklet是通过软中断实现的，所以它本身也是软中断

为了提高中断处理数量，顺道改进处理效率，于是产生了tasklet机制。

Tasklet采用无差别的队列机制，有中断时才执行，免去了循环查表之苦

总结下tasklet的优点：

　　（1）无类型数量限制；

　　（2）效率高，无需循环查表；

　　（3）支持SMP机制；

　　它的特性如下：

　　1）一种特定类型的tasklet只能运行在一个CPU上，不能并行，只能串行执行。

　　2）多个不同类型的tasklet可以并行在多个CPU上。

　　3）软中断是静态分配的，在内核编译好之后，就不能改变。但tasklet就灵活许多，可以在运行时改变（比如添加模块时）。

#### 3、工作队列**work queue**

- 软中断一般是“可延迟函数”的总称，它不能睡眠，不能阻塞，它处于中断上下文，不能进城切换，软中断不能被自己打断，只能被硬件中断打断（上半部），可以并发的运行在多个CPU上。所以软中断必须设计成可重入的函数，因此也需要自旋锁来保护其数据结构。
- 工作队列中的函数处在进程上下文中，它可以睡眠，也能被阻塞，能够在不同的进程间切换，以完成不同的工作。可延迟函数和工作队列都不能访问用户的进程空间，可延时函数在执行时不可能有任何正在运行的进程，工作队列的函数有内核进程执行，他不能访问用户空间地址。

### 四、中断的具体场景

#### 1、/proc/interrupts 文件

```
[root@ansible-1 ~]# cat /proc/interrupts
           CPU0       CPU1
  0:        135          0   IO-APIC-edge      timer
  1:         28          8   IO-APIC-edge      i8042
  4:       1016          0   IO-APIC-edge      serial
  6:          3          0   IO-APIC-edge      floppy
  8:          0          0   IO-APIC-edge      rtc0
  9:          0          0   IO-APIC-fasteoi   acpi
 11:     123914          0   IO-APIC-fasteoi   uhci_hcd:usb1, virtio3
 12:         16       3610   IO-APIC-edge      i8042
 14:          0          0   IO-APIC-edge      ata_piix
 15:          0          0   IO-APIC-edge      ata_piix
 24:          0          0   PCI-MSI-edge      virtio2-config
 25:    1060354          0   PCI-MSI-edge      virtio2-req.0
 26:          0          0   PCI-MSI-edge      virtio1-config
 27:          3          0   PCI-MSI-edge      virtio1-virtqueues
 28:          0          0   PCI-MSI-edge      virtio0-config
 29:        195   12947560   PCI-MSI-edge      virtio0-input.0
 30:         25          1   PCI-MSI-edge      virtio0-output.0
 31:          0          0   PCI-MSI-edge      virtio4-config
 32:       1309          0   PCI-MSI-edge      virtio4-req.0
NMI:          0          0   Non-maskable interrupts
LOC:  164438005  211442518   Local timer interrupts
SPU:          0          0   Spurious interrupts
PMI:          0          0   Performance monitoring interrupts
IWI:   13627325   19468849   IRQ work interrupts
RTR:          0          0   APIC ICR read retries
RES:   28933906   28497582   Rescheduling interrupts
CAL:       4680     616090   Function call interrupts
TLB:    3392270    3890641   TLB shootdowns
TRM:          0          0   Thermal event interrupts
THR:          0          0   Threshold APIC interrupts
DFR:          0          0   Deferred Error APIC interrupts
MCE:          0          0   Machine check exceptions
MCP:       4132       4132   Machine check polls
ERR:          0
MIS:          0
PIN:          0          0   Posted-interrupt notification event
NPI:          0          0   Nested posted-interrupt event
PIW:          0          0   Posted-interrupt wakeup event
```

- 第一列表示IRQ号
- 第二、三列表示相应的CPU核心被中断的次数。在上面的例子中，timer表示中断名称（为系统时钟），i8042表示控制键盘和鼠标的键盘控制器
- NMI和LOC是系统所使用的驱动，用户无法访问和配置

**IRQ号决定了需要被CPU处理的优先级。IRQ号越小意味着优先级越高**

#### 2、**IRQ Balance**

Irqbalance是一个linux的实用程序，它主要是用于分发中断请求到CPU核心上，有助于性能的提升。它的目的是寻求省电和性能优化之间的平衡。你可以使用yum进行安装：

```
yum install irqbalance
```





