---
layout: post
category: Linux
title: Linux 用户空间和内核空间
tagline: by 噜噜噜
tags: 
  - xx
published: true
---



<!--more-->

### 一、虚拟内存



### 二、虚拟地址空间

#### 1、概念

Linux为每一个进程都会分配一个虚拟地址空间，对于32位的操作系统（其指令的位数最大为32位，因此地址码最多32位），虚拟地址空间的大小为![2^{32}](https://private.codecogs.com/gif.latex?2%5E%7B32%7D)B即0~4GB的虚拟地址空间，其中内核空间为1GB。对于64位操作系统，虚拟地址空间的大小为16EB.,即有2的64次方个地址，以32位系统为例：

![img](https://img-blog.csdnimg.cn/20190312215427434.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODgzMDg1,size_16,color_FFFFFF,t_70)

每一个进程的进程控制块PCB（**进程描述符**）都位于内核区，在每一个进程的PCB中有一个文件描述符表（是一个数组），用于标记该进程所打开的所有文件。

每打开一个文件就会占用一个文件描述符，且使用的是空闲的最小的一个文件描述符

![img](https://img-blog.csdnimg.cn/2019031221492982.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODgzMDg1,size_16,color_FFFFFF,t_70)



#### 2、虚拟地址空间的作用

- 方面编译器和操作系统安排程序的地址
- 方便实现各个进程空间之间的隔离，互不干扰，因为每个进程都对应自己的虚拟地址空间
- 实现虚拟存储，从逻辑上扩大了内存

### 三、内核用户和用户空间

#### 1、内核空间和用户空间

对于32位操作系统而言，每个进程的 4G 地址空间中，最高 1G 都是一样的（即所有进程共享内核空间地址），即**内核空间**

剩下的地址空间则为**用户空间**



`为什么要划分内核空间和用户空间？`

cpu的指令分为特权指令和非特权指令：

​	特权指令：这类指令的权限最大，如果使用不当就会导致整个系统崩溃，如清内存、置时钟、分配系统资源、修改虚存的段表和页表，修改用户的访问权限等

​    非特权指令：指的是在程序执行时都可以调用。

比如Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。Linux 系统只使用了 Ring0 和 Ring3 两个运行级别，**当进程运行在Ring3级别时被称为运行在用户态，当进程运行在Ring0级别时被称为运行在内核态。**

![img](https://img-blog.csdn.net/20180702174012506?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW41NzUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**因此**，**区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性**



#### 2、用户空间到内核空间的切换过程

首先所有的系统资源管理都是在内核空间中完成的。比如读写磁盘文件，分配回收内存，从网络接口读写数据等等。我们的应用程序是无法直接进行这样的操作的。但是我们可以通过内核提供的接口来完成这样的任务（**系统调用**）

简单说就是应用程序把高科技的事情(从磁盘读取文件)**外包给了系统内核**，系统内核做这些事情既专业又高效

**主要有三种方式：**

- 系统调用

  这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统的服务来完成工作

- 异常

  当cpu执行的用户态下的程序时，发生了一些异常，就会触发由当前进程预留的一些异常处理程序中，也就转到了内核态

- 外围设备的中断

  当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等

#### 3、Linux内部架构

**有了用户空间和内核空间，整个linux内部结构可以分为三部分，从最底层到最上层依次是：硬件-->内核空间-->用户空间**

![img](https://images0.cnblogs.com/blog/305504/201308/19221748-2f795fab93eb4ebfae5cce4a876e7164.png)

### 四、进程上下文

对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。一个进程的上下文可以分为三个部分：

- 用户级上下文：

  正文、数据、用户堆栈以及共享存储区

- 寄存器上下文：

  通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)

- 系统级上下文：

  进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈